### 01. 事件循环机制
- JS 是单线程的。JS 引擎同一时间只能执行一个任务（方法）。为了避免长耗时的任务阻塞主线程，浏览器提供了任务队列。主线程在可执行上下文栈（ECS）中执行同步代码，有的代码调用异步API，注册回调函数到事件列表中，异步任务有了运行结果（比如setTimeout第二个参数指定的延时到了）就将对应的回调函数推入任务队列（task queue）中等待主线程执行。ECS 中的同步代码执行完毕，读取任务队列，取出队首的回调放入执行栈中执行，如此循环往复就是事件循环机制。而根据不同的来源，异步任务分为宏任务和微任务，只有清空了当前这一轮事件循环里的微任务才会开始下一轮事件循环，因此promise总是比定时器先执行，因为promise是本次事件循环的微任务，而定时器是下一个宏任务了。
> 微任务来源：
- Promise
- MutationObserver
- Object.observe（已废弃）
- process.nextTick（node 环境）
> 总结流程：
- 一开始script脚本作为宏任务执行
- 同步代码直接执行，异步代码根据不同来源推入宏任务队列或者微任务队列
- 同步代码执行完毕，读取任务队列队首的宏任务
- 宏任务执行完毕，执行其相关的微任务
- 关联的所有微任务执行完毕，读取下一个宏任务
### 02. setTimeout 的工作原理
- 涉及到了浏览器的事件循环机制。它是一个webApi，会注册一个回调函数，在经过指定的延时后，将回调函数推入事件队列，等待主线程执行。
### 03. requestAnimationFrame 是什么
- 浏览器在进行下一帧更新渲染之前会执行 requestAnimationFrame 注册的回调函数，可以通过这个 API 去实现流畅度较高的动画效果。现在大多数设备的屏幕刷新率是1秒60次，即 60 fps，requestAnimationFrame 的原理就是与屏幕的刷新频率保持同步，在重渲染下一帧前执行传入的回调函数。因此它的兼容方案使用 setTimeout，传入的延时也是 1000/60。
### 04. requestIdleCallback 是什么
### 05. 描述下原型链
- JS 是基于原型机制实现的继承。我们一般通过构造函数生成实例对象，实例对象继承了它原型对象上的属性和方法，它的原型对象指向了构造函数的prototype属性，而原型对象也是一个对象，它自己的原型对象也是其构造函数的 prototype 属性即Object.prototype，Object.prototype 这个对象的原型指向 null，到达原型链的终点；在 JS 中函数也是一个对象，函数对象也有自己的原型对象即 Function.prototype；Function 构造函数本身也是一个对象，其原型对象是构造函数的prototype属性（自己就是构造函数因此有Function.__proto__ === Function.prototype）同理 Function.prototype 这个对象的原型也指向 Object.prototype。这样就构成了从普通实例对象或者函数对象到 null 的原型链。
### 06. instanceof 原理
- 查看 instanceof 运算符右侧构造函数的 prototype 属性是否出现在运算符左侧对象的原型链上
```
// 手写实现
```
### 07. 原型链和作用域链的区别
- 作用域链是指变量查找的路径，用来查找变量标识符的，是词法作用域的一种实现方式。
> 词法作用域即静态作用域，指函数的作用域在函数定义的时候就确定好了，与之对应的是动态作用域，如 bash 语言
- 原型链是用来查找对象属性的。沿着对象的原型一级一级查找属性，这条查找属性的路径称为原型链，是原型继承的一种实现方式。
- 二者的不同: 首先二者的作用完全不同，其次查找的终点不同，原型链查找的终点是 null，作用域链的终点是全局作用域；此外当在原型链中找不到一个属性的时候，会得到一个 undefined，而试图访问一个作用域链中不存在的变量则会抛出一个引用错误。
### 05. 描述一下 promise
- 是异步编程的解决方案。从语法上说，它是一个构造函数，用来生成promise实例，使用then方法注册回调函数可以得到异步任务的结果，每个then方法返回一个新的promise实例，这允许promise进行链式调用，在多个异步任务相互依赖的场景中，很好的解决了传统纯回调方式造成的“回调地狱”问题，在promise链的末尾使用catch方法可以捕获前面任一个then方法中抛出的错误，简化了异常处理流程；promise有三个状态，只能由pending变到fulfilled或pending变到rejected，并且一旦确定就不会再次改变，即使在任务结束后也可以拿到结果。
### 06. promise 的优缺点：
#### 优：
- 多个回调函数嵌套调用，外部回调函数异步执行的结果是内部回调函数执行的条件，这样的场景用传统纯回调的方式去处理会形成“回调地狱”，代码互相嵌套，并且每一个函数都得单独做异常处理，使得调试和维护都变得异常困难。而promise允许链式调用，统一使用then方法依次注册回调函数，并在promise链的末尾使用catch方法捕获错误，将嵌套的回调函数铺平了，很好的解决了“回调地狱”的问题。
- promise状态一经确定就永不再变，任何时候都可以拿到异步任务的结果。
#### 缺：
- 一旦新建就立即执行，无法取消
- 当处于pending状态时，无法得知目前进展到哪一阶段，其实就是没有提供onProgress
- promise内部产生的错误即使未经捕获也不会影响到外面代码的执行，这导致promise链中的错误很容易被忽略，所以推荐在promise链的末尾添加一个catch方法
### 07. 中断promise链的方法
- 返回一个pending状态的promise即可
### 08. JS 中的数据类型及区别
- 基本数据类型和引用数据类型。基本数据类型包括 null、undefined、boolean、number、string 和 ES6 新增的 symbol；引用类型就是 object。区别是基本数据类型在变量中存储的是值，而引用类型在变量中存储的是一个指针。
### 09. 数据类型的判断
- 使用 typeof 运算符可以正确判断基本数据类型里除 null 之外的其他数据类型和引用类型里的函数对象，使用 instanceof 运算符可以判断一个对象是否是某个构造函数的实例，Object.prototype.toString.call(value) 可以正确判断所有数据类型
### 05. null 是对象吗，或者说 typeof 为什么对 null 显示为 object
### 04. null和undefined的区别
- null 表示此处为空，即没有值，而undefined表示未定义
- 使用 Number() 构造函数转换时，null 结果为0；undefined 为 NaN
- undefined 表示该值已声明，但没有被赋值
### 10. document、body、html、window 层级的关系
- window 是 BOM 的核心对象，除了用来获取和设置浏览器的属性，也作为全局对象
- document 是文档相关的对象，是 window 对象的一个属性
- html 和 body 是文档标签，body 通常包含在 html 中
### 11. addEventListener 事件监听器
- 第三个参数是可选的对象，其中 capture 表示事件处理函数在事件传播的哪个阶段被触发，true 是捕获阶段，false 是冒泡阶段，默认为false；once 表示事件处理函数在添加之后最多只调用一次，若为 true，表示在被调用之后会自动移除；
### 12. 事件的冒泡和捕获
### 13. 所有事件都冒泡吗
- 不是。blur、focus、mouseenter 和 mouseLeave 不冒泡
### 17. 什么是 this
### 18. 描述 call、apply 和 bind
### 19. webpack 的 loader 和 plugin 有什么区别
### 20. 描述虚拟 DOM
- 本质是用一个 JS 对象去描述DOM节点，对真实 DOM 的一层抽象。在浏览器中直接操作真实 DOM 是很昂贵的，JS 引擎和渲染线程需要互相通信，并且每个 DOM 对象上挂载着很多属性，自身也比较庞大，频繁操作真实 DOM，会产生额外的的性能开销，因此我们需要这一层抽象，在发生改变后对比新旧两棵虚拟 DOM 树，尽可能一次性将差异更新到 DOM中
- 更重要的意义是使得跨平台开发成为可能，可以把代表 DOM 的 JS 代码编译成其他平台的代码
### 21. ES6 和 ES5 的继承
### 22. 模块化
- commonJs 和 ES6 模块的区别
- commonJS 导出的是值的拷贝；es6 模块输出的是值的引用
- commonJS 模块是运行时同步加载，因为服务端加载的模块都是存放在本地的磁盘中，加载起来比较快，不用考虑异步的方式，require 读取文件并执行，返回文件中的 module.exports 对象，对象只有在脚本运行时才能生成；而 ES6 模块是编译时输出接口，它的对外接口只是一个静态的定义，在代码解析阶段就会生成。
### 23. 模块的异步加载
### 24. V8 垃圾回收
### 25. 函数防抖和节流
#### 防抖
- 限制一个函数在事件触发的N秒以后再执行，若期间事件再次被触发，则重新计算延迟。
#### 节流
- 规定在单位时间内只能有一次事件可以真正触发函数的执行，其他触发被丢弃。
### 26. apply 的作用
- 改变 this 指向
- 将数组转换为函数参数，可用扩展运算符替代


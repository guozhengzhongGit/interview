### 01. HTTP 和 TCP 的不同
- 在 OSI 网络分层模型中， TCP 工作在传输层，而 HTTP 工作在应用层，是一个上层协议，它是基于传输层的
- tcp 层的传输单位是段（segment），http 传输的单位我们一般称为消息或者报文（message）
### 02. TCP 和 UDP 的不同
- TCP 协议是一个面向连接的可靠的基于字节流的传输层协议。它是一个有状态的协议，需要先与对方建立连接然后才能发送数据，且保证数据不丢失不重复；
- UDP 则无需建立连接就可以发送数据，但不保证数据一定会发送给对方；
- TCP 的数据是连续的字节流，而UDP则是分散的小数据包，顺序发，乱序收。
### 03. 输入 URL 到页面的呈现
###### 网络连接阶段
- 浏览器根据地址栏中输入的信息生成完整的 `URL`，使用 `DNS` 解析域名查找对应的 `IP` 地址，这里 `DNS` 是有缓存的，会依次在浏览器、操作系统里查找缓存，然后是本地 `hosts` 文件中的域名记录，都没有找到的话就去访问当前的 `DNS` 服务器，比如三大运营商或者手动设置谷歌的 `8.8.8.8`，还没有找到的话就由当前 `DNS` 服务器向根域名服务器查找
>`DNS` 解析使用 `udp` 协议
>
>一个域名可以对应多个 `IP`，因此可以利用 `DNS` 做负载均衡
- 成功获取到服务器 `IP` 地址，需要经过三次握手建立 `TCP` 连接。首先浏览器发送包含 `SYN` 为 1 的连接请求报文段，服务器接收到后回复 `SYN+ACK` 的确认报文段，客户端成功接收后再向服务器发送 `ACK` 报文段，三次握手完成，TCP 通道建立
- 有了可靠的 `TCP` 连接通道后就可以发送 `HTTP` 请求了，服务器处理请求并返回响应。浏览器接收响应并解析，如果发现返回的是重定向相关的状态码比如 301，则读取响应头中`Location` 字段的地址重新发送请求，待资源返回后进行处理。
>当然在请求链路上存在着多级代理服务器或 `CDN`，资源也可能由它们返回
- 浏览器解析响应内容，根据响应资源的 `Content-type` 或者对响应实体进行 `MIME` 类型嗅探确定资源类型，同时会进行安全检查，如果域名和响应数据匹配已知的恶意网站，或者受到**跨域限制**，则显示警告或者抛出错误，不会将未允许的敏感跨站点数据发送给渲染进程
###### 页面渲染阶段
- 浏览器自上而下解析 `HTML` 文件，通过词法分析、语法分析将 `HTML` 字符串解析为浏览器能理解的结构，构建 `DOM` 树，在这过程中如果遇到 `JS` 脚本则会暂停 `DOM` 解析，优先执行脚本代码
- 解析 `CSS`，计算出每个 `DOM` 节点的样式
- 布局。计算 `DOM` 树中**可见元素**的几何位置信息
- 分层。将页面划分成多个图层
- 栅格化。合成线程将图层划分为一个个图块，优先将视口附近的图块通过栅格化转换为位图
- 所有图块光栅化完成，绘制并显示到页面上
### 04. 跨域
- 浏览器遵循同源策略(sop)这一安全机制。限制不同源之间的文档或脚本如何进行交互，保证用户的信息安全，防止恶意网站修改页面内容，窃取隐私数据。同源策略是由浏览器实现的，这意味着此策略并不适用于从服务器或者任何其他 HTTP 客户端发出的请求。
- 协议、域名、端口完全相同
- 共三种行为受到限制：不同源的页面 DOM 无法访问，cookie、localStorage、indexDB 等本地存储无法读取，AJAX 请求不能发送
#### 解决办法
- 对于cookie，可以设置其一级域名 domain，这样二级域名就可以读取这个 cookie
- 对于 iframe ，父窗口打开不同源的 iframe，无法获取其 DOM。如果两个窗口一级域名相同，只是二级域名不同，也可以设置 document.domain 属性来解决
- 若是完全不同源，则可以使用片段标识符、window.name 和 HTML5 的标准 API postMessage 来实现跨窗口通信，这样读写其他窗口的 localStorage 也成为可能。
- 对于 AJAX 请求，可以使用 jsonp，cors 和 websocket 来发送跨域请求，也可以通过架设代理服务器来实现。
### 05. jsonp 原理
- 利用 script 标签的 src 可以跨域的特性来完成。前端预先定义一个回调函数，然后构造请求 URL，该回调也包含在查询字符串中，前端动态创建一个 script 标签，其 src 属性值就是拼接好的 URL，这样就发起了一次  GET 请求。服务端收到请求后将数据放在回调函数参数位置进行返回；script 请求的脚本会作为代码直接运行，回调函数在前端执行，这样就可以拿到服务端返回的数据了，需要前后端互相配合，只支持 GET 方法。
### 06. CORS 原理
- 跨域资源共享。是 W3C 标准，通过设置额外的请求头来告知浏览器是否允许访问不同源服务器上的资源。
- 浏览器将跨域请求分为简单请求和非简单请求
- 简单请求：get、post、head 方法，请求头只能包含基本的 Accept、Accept-language、content-language、content-type等，其中content-type只能是 text/plain、multipart/form-data、application/x-www-form-urlencoded 这三种，**简单请求其实就是普通的 html form 在不依赖脚本的情况下可以发出的请求**
- 对于简单请求，浏览器直接发送跨域请求，在请求头中有 Origin 字段，说明本次请求来自于哪个域，协议域名端口都包含；服务器允许这个源访问，就在响应头中设置 Access-Control-Allow-Origin 字段，浏览器正常接收请求；若不允许该跨域请求，则响应头中不包含 Access-Control-Allow-Origin 字段，浏览器会抛出一个错误
- 非简单请求，需要浏览器先用 options 方法发送一个预检请求(preflight)，请求头中包含 Origin、Access-control-Request-Method、Access-Control-Request-Headers 等字段，服务端判断是否允许该跨域请求，如果允许则返回的响应头中包含 Access-Control-Allow-Origin、Access-Control-Allow-Methods 和该次预检请求的有效时长 Access-Control-Max-Age，然后浏览器再发送真正的跨域请求
### 07. 把 HTTP 请求换为 HTTPS
- 可以在 axios 里用请求拦截器做
- 也可以使用 meta 标签
### 08. https
### 09. http 缓存

### 10. web 安全
#### xss(cross site scripting)跨站脚本攻击
- 它是一种代码注入攻击，攻击者在目标网站上注入恶意脚本，使之在用户的浏览器上运行，获取用户隐私数据或敏感信息等。本质是恶意代码未经过滤，与网站的正常代码混到了一起被执行。最常见的注入方式是来自用户输入的信息，也可以来自第三方链接，url 参数等。根据攻击的来源，xss 攻击可分为三类：存储型、反射型和 DOM 型。
##### 存储型
- 攻击者将恶意代码提交到目标网站的数据库中，普通用户浏览目标网站，恶意代码从服务端返回并执行。这种攻击常见于带有用户保存数据功能的网站，比如论坛发帖，输入商品评论等。
##### 反射型
- 攻击者构造一段包含恶意代码的特殊 URL，用户点击，服务端将恶意代码取出拼接到 HTML 中返回，浏览器解析，恶意代码被执行。反射型 XSS 漏洞常见于通过 url 传递参数的功能，比如网站搜索。这种攻击需要用户主动打开恶意链接才能生效，因此攻击者会使用多种手段诱导用户点击。
##### DOM型
- 攻击者构造一段包含恶意代码的特殊 URL，用户点击，前端取出URL中的恶意代码并执行，DOM 型的 XSS 攻击不经过服务端，属于前端的安全漏洞。
##### 防御手段
- 输入过滤。对用户输入内容进行检查和过滤，转义其中的<>等特殊字符，也可以使用白名单机制。
- 前端应该避免使用 .innerHTML、document.write() 等方法，避免把不可信的数据直接插到页面上
- DOM 中的内联事件监听器比如 onload，onerror，a 标签的 href 属性等都能把字符串作为代码运行，应尽量避免
- 在使用现代前端框架时，我们需要避免使用v-html和dangerouslySetInnerHTML等api
- 为 cookie 设置 httponly 属性，禁止客户端脚本读取cookie
- 使用 CSP
#### CSRF 跨站请求伪造
- 攻击者诱导普通用户进入第三方网站，在第三方网站中向目标网站发送跨站请求，利用普通用户已经在目标网站获取的认证凭证(通常是cookie)，达到冒充用户对目标网站执行某项操作的目的。
- 跨站请求有多种方式，图片URL，超链接，表单提交等
##### 特点
- 它需要用户提前登录
- CSRF 攻击是冒充用户身份对目标网站提交操作，而不是直接窃取数据
- 无法获得用户的登录凭证，仅仅是冒用
##### 防御手段
- 验证 Referer 请求头
- 前端页面添加验证码
- 验证 token
- 为 cookie 设置 same-site 属性，禁止携带第三方 cookie

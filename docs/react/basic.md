
### 01. key 属性及其作用
- 为了提升 diff 性能。diff 算法对 DOM 操作做了假设和预判，只做同层级的比较，如果元素类型发生了改变，则直接删除重建。key 是 React 用来匹配组件树中新旧子组件的标识，能够让 React 了解哪些组件需要被变更。比如一个列表，如果没有 key 作为标记，当我们在数据头部或中间某个索引位置插入或者删除数据时，会造成原本没有发生过变更的节点重新销毁并创建，产生额外的性能损耗；若合理设置 key 值则下次渲染是 react 都能识别这些组件，不会对它们进行变更操作。key 值需要唯一且稳定，不合理的 key 值除了会增加渲染成本甚至还会造成组件的状态丢失产生 bug。比如用随机数作为 key；比如用数组索引作为 key 时，如果对数据进行排序，反转等操作也会导致状态误判。后端 API 返回给前端的数据中一般都有一个像 ID 这样的字段，它全局唯一且稳定保存在持久层中，很适合用作 key 值。
- - -
### 03. react的受控组件和非受控组件
- 所谓的受控组件和非受控组件是针对表单元素而言的。HTML 的表单元素可以自己维护数据并根据用户输入进行更新，而在react中，可变状态通常保存在组件的state中并且只能通过使用setState来进行更新。渲染表单元素的组件同时控制着用户输入过程中表单发生的数据变化，这样的表单元素就是受控组件，受控组件必须绑定onChange事件，否则React将在浏览器控制台给出警告；对于非受控组件可以使用ref从DOM节点中获取表单数据。
- - -
### 04. 前端路由原理
- 现代前端框架构建的单页应用均使用前端路由，本质是描述 URL 与 UI 之间的映射关系，通过改变 URL，在**不重新请求请求页面的情况下更新视图**。
- 前端路由可以使用两种方式去实现: hash 和 history API
- hash 只作用于浏览器不会在请求中发送给服务端；hash 发生了变化，浏览器并不会重新给后端发送请求加载页面，但会在浏览器中留下历史记录，同时触发 hashChange 事件，我们可以通过这个事件监听到 hash 的变化，使用 window.location.hash 获取到当前的 hash 去渲染对应的视图
- history API 有 history.go()、history.bacK()、history.forward()，以及 HTML5 新增的两个 api pushState() 和 replaceState() 来添加和修改浏览器历史记录，当调用它们改变 URL 后，浏览器同样不会发送请求该 URL，它们会触发 popState 事件。
- 两种方式的异同:
- 从实现上来说，pushState 设置的 URL 可以是与当前 URL 同源的任意 URL；而 hash 只能够改变 url 中 # 号后面的部分，因此只能设置与当前同文档的 URL
- pushState 可以设置与当前 URL 一样的 URL，也会保存历史记录到栈中；而 hash 设置的 URL 必须与当前不一样才会触发记录添加到栈中
- history 通过 popState 事件来监听 url 变化，但 pushState 和 replaceState 或者 a 标签改变 URL 却不会触发 popstate 事件，需要我们拦截 pushState 调用和 a 标签的点击事件来检测 URL 的变化
- history 直接修改 URL 的路径。若用户手动刷新，会发送不同的路径的请求到后端，需要将路径重定向到同一个 HTML 资源，不然会出现 404
- history 中的 replaceState 直接替换当前的历史记录，不会在栈中新增
- - -
### 05. 现代前端框架的优劣
#### 优：
- 自动更新视图，不需要开发者手动操作DOM。框架完成了数据与 UI 的映射，会自动保持状态与 UI 的同步，开发者可以更专注于业务逻辑的处理和编写
- 组件化。单一功能拆分到组件中，提升项目的可维护性；可以把公共的部分抽离出来做成一个可复用的组件，提升开发效率，提高了代码复用性。
- 虚拟 DOM。减少操作真实 DOM 的性能开销，更重要地是使跨平台成为可能
#### 劣：
- 代码均由 JS 动态生成，不利于 SEO
- 加载的 JS 体积过大，首屏白屏时间边长
- 框架本身只关注视图层，对于逻辑复杂的应用需要引入额外的数据管理方案
